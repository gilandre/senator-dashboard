<?php

namespace App\Controllers;

use App\Core\Controller;
use App\Models\AccessLog;
use App\Models\ImportHistory;
use App\Services\CsvImportService;
use App\Services\CsvValidationService;

class ImportController extends Controller
{
    private CsvImportService $csvImportService;
    private CsvValidationService $csvValidationService;
    private $db;
    
    public function __construct()
    {
        parent::__construct();
        
        // Définir explicitement le layout à utiliser
        $this->layout = 'layouts/app';
        
        $this->csvImportService = new CsvImportService();
        $this->csvValidationService = new CsvValidationService();
        $this->db = \App\Core\Database::getInstance();
    }
    
    /**
     * Affiche la page d'importation
     */
    public function index()
    {
        // Supprimer les anciennes données de session si elles existent
        if (isset($_SESSION['import_data'])) {
            unset($_SESSION['import_data']);
        }
        if (isset($_SESSION['validation'])) {
            unset($_SESSION['validation']);
        }
        
        $this->view('import/index', [
            'title' => 'Importation de données',
            'current_page' => 'import'
        ]);
    }
    
    /**
     * Traite le téléchargement du fichier CSV
     */
    public function upload()
    {
        try {
            error_log("ImportController::upload - Début du processus");
            error_log("ImportController::upload - POST data: " . print_r($_POST, true));
            error_log("ImportController::upload - FILES data: " . print_r($_FILES, true));
            
            // Vérifier si le formulaire a été soumis
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                error_log("ImportController::upload - Méthode non POST");
                $this->redirect('/import');
                return;
            }
            
            // Vérifier si un fichier a été téléchargé
            if (!isset($_FILES['csv_file']) || $_FILES['csv_file']['error'] !== UPLOAD_ERR_OK) {
                error_log("ImportController::upload - Aucun fichier ou erreur de téléchargement");
                $this->setFlash('error', 'Aucun fichier n\'a été téléchargé ou une erreur s\'est produite');
                $this->redirect('/import');
                return;
            }
            
            // Récupérer les options d'importation et s'assurer qu'elles sont définies
            $separator = isset($_POST['separator']) && !empty($_POST['separator']) ? $_POST['separator'] : ';';
            error_log("ImportController::upload - Séparateur après vérification: '$separator'");
            
            $hasHeader = isset($_POST['has_header']) && $_POST['has_header'] === 'on';
            $validateData = isset($_POST['validate_data']) && $_POST['validate_data'] === 'on';
            
            error_log("ImportController::upload - Options: separator=$separator, hasHeader=" . ($hasHeader ? 'true' : 'false') . ", validateData=" . ($validateData ? 'true' : 'false'));
            
            // Stocker le fichier téléchargé temporairement
            $tempFile = $this->storeTempFile($_FILES['csv_file']);
            error_log("ImportController::upload - Fichier temporaire créé: $tempFile");
            
            // Lire le contenu du CSV
            $data = $this->csvImportService->readCSV($tempFile, $separator, $hasHeader);
            error_log("ImportController::upload - Lecture CSV terminée, " . count($data) . " lignes trouvées");
            
            // Si validation activée, valider les données
            if ($validateData) {
                error_log("ImportController::upload - Validation demandée, traitement en cours");
                $this->csvValidationService->validateImportData($data);
                
                $errorCount = $this->csvValidationService->getErrorCount();
                $warningCount = $this->csvValidationService->getWarningCount();
                error_log("ImportController::upload - Validation terminée: $errorCount erreurs, $warningCount avertissements");
                
                // Stocker les résultats de validation en session
                $_SESSION['validation'] = [
                    'errors' => $this->csvValidationService->getErrors(),
                    'warnings' => $this->csvValidationService->getWarnings(),
                    'corrections' => $this->csvValidationService->getCorrections(),
                    'error_count' => $errorCount,
                    'warning_count' => $warningCount
                ];
                
                // Stocker les données en session
                $_SESSION['import_data'] = [
                    'data' => $data,
                    'temp_file' => $tempFile,
                    'separator' => $separator,
                    'has_header' => $hasHeader
                ];
                
                // Vérifier s'il y a des erreurs bloquantes
                $hasBlockingErrors = $this->csvValidationService->hasBlockingErrors();
                error_log("ImportController::upload - Erreurs bloquantes: " . ($hasBlockingErrors ? 'oui' : 'non'));
                
                if ($hasBlockingErrors) {
                    error_log("ImportController::upload - Redirection vers /import à cause des erreurs bloquantes");
                    $this->setFlash('error', 'Des erreurs ont été détectées dans le fichier. Veuillez les corriger avant de continuer.');
                    $this->redirect('/import');
                    return;
                }
                
                // Rediriger vers la page de validation
                error_log("ImportController::upload - Redirection vers /import/validate pour validation");
                $this->redirect('/import/validate');
                return;
            }
            
            error_log("ImportController::upload - Pas de validation demandée, importation directe");
            // Si pas de validation, importer directement les données
            $this->importData($data);
            
            // Nettoyer le fichier temporaire
            @unlink($tempFile);
            
            error_log("ImportController::upload - Importation terminée avec succès");
            $this->setFlash('success', 'Les données ont été importées avec succès.');
            $this->redirect('/dashboard');
            
        } catch (\Exception $e) {
            error_log("ImportController::upload - Erreur: " . $e->getMessage());
            error_log("ImportController::upload - Trace: " . $e->getTraceAsString());
            $this->setFlash('error', 'Erreur lors de l\'importation: ' . $e->getMessage());
            $this->redirect('/import');
        }
    }
    
    /**
     * Affiche la page de validation des données
     */
    public function validateView()
    {
        // Vérifier si des données d'importation existent en session
        if (!isset($_SESSION['import_data']) || !isset($_SESSION['validation'])) {
            $this->setFlash('error', 'Aucune donnée d\'importation disponible. Veuillez télécharger un fichier.');
            $this->redirect('/import');
            return;
        }
        
        $data = $_SESSION['import_data']['data'];
        $validation = $_SESSION['validation'];
        
        $this->view('import/validate', [
            'title' => 'Validation des données',
            'current_page' => 'import',
            'data' => $data,
            'errors' => $validation['errors'],
            'warnings' => $validation['warnings'],
            'corrections' => $validation['corrections'],
            'error_count' => $validation['error_count'],
            'warning_count' => $validation['warning_count']
        ]);
    }
    
    /**
     * Traite l'importation finale après validation
     */
    public function process()
    {
        try {
            // Vérifier si c'est une requête AJAX
            $isAjaxRequest = !empty($_SERVER['HTTP_X_REQUESTED_WITH']) && 
                             strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest';
            
            error_log("ImportController::process - Requête AJAX: " . ($isAjaxRequest ? 'Oui' : 'Non'));
            
            // Vérifier si l'utilisateur est connecté
            if (!$this->auth->isLoggedIn()) {
                error_log("ImportController::process - Utilisateur non connecté");
                // Pour les requêtes AJAX, retourner une erreur JSON
                if ($isAjaxRequest) {
                    header('Content-Type: application/json');
                    echo json_encode(['success' => false, 'error' => 'Vous devez être connecté pour effectuer cette action.']);
                    exit;
                }
                
                $this->redirect('/login');
                return;
            }
            
            error_log("ImportController::process - Utilisateur connecté: " . $_SESSION['username']);
            
            // Vérifier si c'est une requête POST
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                error_log("ImportController::process - Méthode non autorisée: " . $_SERVER['REQUEST_METHOD']);
                
                // Pour les requêtes AJAX, retourner une erreur JSON
                if ($isAjaxRequest) {
                    header('Content-Type: application/json');
                    echo json_encode(['success' => false, 'error' => 'Méthode non autorisée']);
                    exit;
                }
                
                $this->setFlash('error', 'Méthode non autorisée.');
                $this->redirect('/import');
                return;
            }
            
            // Vérifier si des données d'importation existent en session
            if (!isset($_SESSION['import_data'])) {
                error_log("ImportController::process - Aucune donnée d'importation disponible");
                
                // Pour les requêtes AJAX, retourner une erreur JSON
                if ($isAjaxRequest) {
                    header('Content-Type: application/json');
                    echo json_encode(['success' => false, 'error' => 'Aucune donnée d\'importation disponible']);
                    exit;
                }
                
                $this->setFlash('error', 'Aucune donnée d\'importation disponible.');
                $this->redirect('/import');
                return;
            }
            
            error_log("ImportController::process - Données d'importation trouvées en session");
            
            $importData = $_SESSION['import_data'];
            $tempFile = $importData['temp_file'] ?? null;
            
            // Vérifier que le fichier temporaire existe
            if ($tempFile && !file_exists($tempFile)) {
                error_log("ImportController::process - Fichier temporaire non trouvé: $tempFile");
                
                // Pour les requêtes AJAX, retourner une erreur JSON
                if ($isAjaxRequest) {
                    header('Content-Type: application/json');
                    echo json_encode(['success' => false, 'error' => 'Fichier temporaire non trouvé']);
                    exit;
                }
                
                $this->setFlash('error', 'Fichier temporaire non trouvé.');
                $this->redirect('/import');
                return;
            }
            
            // Initialiser le suivi de progression
            $_SESSION['import_progress'] = 0;
            $_SESSION['import_status'] = 'processing';
            $_SESSION['import_message'] = 'Préparation du fichier...';
            
            // Récupérer les données d'importation
            $data = $importData['data'];
            $totalRows = count($data);
            
            // Détecter si c'est un fichier volumineux qui nécessite un traitement asynchrone
            $isLargeFile = $totalRows > 4000;
            
            error_log("ImportController::process - $totalRows lignes à traiter" . ($isLargeFile ? " (fichier volumineux)" : ""));
            
            // Préparer des statistiques par défaut
            $importStats = [
                'total' => $totalRows,
                'imported' => 0,
                'duplicates' => 0,
                'errors' => 0
            ];
            
            // Pour les fichiers volumineux, configurer le traitement asynchrone
            if ($isLargeFile) {
                error_log("ImportController::process - Configuration du traitement asynchrone");
                
                // Statistiques par défaut pour l'affichage immédiat
                $importStats = [
                    'total' => $totalRows,
                    'imported' => 0,
                    'duplicates' => 0,
                    'errors' => 0,
                    'async' => true
                ];
                
                // Stocker directement les données en session pour le traitement asynchrone
                $_SESSION['async_import'] = [
                    'data' => $data,
                    'status' => 'pending',
                    'start_time' => time(),
                    'processed' => 0,
                    'total' => $totalRows,
                    'imported' => 0,
                    'duplicates' => 0,
                    'errors' => 0,
                    'filename' => basename($tempFile ?? 'import.csv')
                ];
                
                // Démarrer le traitement asynchrone
                $this->startAsyncImport();
                
                // On ne garde plus les données en mémoire pour le retour
                unset($data);
                
                // Nettoyer le fichier temporaire (sera fait par le processus asynchrone)
                // @unlink($tempFile);
                
                // Enregistrer les statistiques en session pour la page de confirmation
                $_SESSION['import_stats'] = $importStats;
                $_SESSION['import_progress'] = 5; // Juste commencé
                $_SESSION['import_status'] = 'async_processing';
                $_SESSION['import_message'] = 'Importation volumineuse en cours de traitement en arrière-plan...';
                
                // Si c'est une requête AJAX, retourner une réponse JSON
                if ($isAjaxRequest) {
                    header('Content-Type: application/json');
                    echo json_encode([
                        'success' => true,
                        'stats' => $importStats,
                        'progress' => 5,
                        'status' => 'async_processing',
                        'message' => 'Importation volumineuse en cours de traitement en arrière-plan...',
                        'async' => true
                    ]);
                    exit;
                }
                
                // Rediriger vers la page de confirmation
                $this->redirect('/import/confirmation');
                return;
            }
            
            // Traitement standard pour les fichiers de taille normale
            $importStats = $this->importData($data, $isAjaxRequest);
            
            // Nettoyer les variables pour libérer la mémoire
            unset($data);
            gc_collect_cycles();
            
            // Nettoyer le fichier temporaire
            @unlink($tempFile);
            
            // Enregistrer les statistiques en session pour la page de confirmation
            $_SESSION['import_stats'] = $importStats;
            $_SESSION['import_progress'] = 100;
            $_SESSION['import_status'] = 'completed';
            $_SESSION['import_message'] = 'Importation terminée avec succès!';
            
            // Sauvegarder l'historique d'importation dans la base de données
            $filename = basename($tempFile);
            error_log("ImportController::process - Sauvegarde des statistiques d'importation pour le fichier $filename");
            try {
                ImportHistory::saveImportHistory($importStats, $filename);
                error_log("ImportController::process - Sauvegarde réussie dans import_history");
            } catch (\Exception $e) {
                error_log("ImportController::process - Erreur lors de la sauvegarde dans import_history: " . $e->getMessage());
            }
            
            // Si c'est une requête AJAX, retourner une réponse JSON
            if ($isAjaxRequest) {
                header('Content-Type: application/json');
                echo json_encode([
                    'success' => true,
                    'stats' => $importStats,
                    'progress' => 100,
                    'status' => 'completed',
                    'message' => 'Importation terminée avec succès!'
                ]);
                exit;
            }
            
            // Rediriger vers la page de confirmation
            $this->redirect('/import/confirmation');
            
        } catch (\Exception $e) {
            error_log("ImportController::process - Erreur: " . $e->getMessage());
            error_log("ImportController::process - Trace: " . $e->getTraceAsString());
            
            // Mettre à jour le statut de progression en cas d'erreur
            $_SESSION['import_status'] = 'error';
            $_SESSION['import_message'] = 'Erreur: ' . $e->getMessage();
            
            // Si c'est une requête AJAX, retourner une réponse JSON
            if (isset($isAjaxRequest) && $isAjaxRequest) {
                header('Content-Type: application/json');
                echo json_encode([
                    'success' => false,
                    'error' => $e->getMessage(),
                    'status' => 'error',
                    'message' => 'Erreur: ' . $e->getMessage()
                ]);
                exit;
            }
            
            $this->setFlash('error', 'Erreur lors de l\'importation: ' . $e->getMessage());
            $this->redirect('/import');
        }
    }
    
    /**
     * Affiche la page de confirmation après importation réussie
     */
    public function confirmation()
    {
        // Vérifier si des statistiques d'importation existent en session
        if (!isset($_SESSION['import_stats'])) {
            $this->setFlash('error', 'Aucune statistique d\'importation disponible.');
            $this->redirect('/import');
            return;
        }
        
        $stats = $_SESSION['import_stats'];
        
        // Recalculer le taux de succès si nécessaire pour s'assurer de la cohérence
        if (!isset($stats['success_rate'])) {
            $stats['success_rate'] = ($stats['total'] > 0) 
                ? round(100 * (($stats['imported'] + $stats['duplicates']) / $stats['total'])) 
                : 0;
        }
        
        $this->view('import/confirmation', [
            'title' => 'Importation terminée',
            'current_page' => 'import',
            'stats' => $stats
        ]);
    }
    
    /**
     * Termine l'importation et nettoie les données de session
     */
    public function finish()
    {
        // Nettoyer les données de session
        unset($_SESSION['import_data']);
        unset($_SESSION['validation']);
        unset($_SESSION['import_stats']);
        unset($_SESSION['import_progress']);
        unset($_SESSION['import_status']);
        unset($_SESSION['import_message']);
        
        // Définir un message
        $this->setFlash('success', 'Les données d\'importation ont été nettoyées.');
        
        // Rediriger vers la page d'importation
        $this->redirect('/import');
    }
    
    /**
     * Affiche la page d'historique des importations
     */
    public function history()
    {
        // Vérifier si l'utilisateur est connecté
        $this->requireLogin();
        
        // Récupérer les filtres de date
        $startDate = $_GET['start_date'] ?? date('Y-m-d', strtotime('-30 days'));
        $endDate = $_GET['end_date'] ?? date('Y-m-d');
        
        // Obtenir l'historique des importations
        $history = [];
        if (!empty($startDate) && !empty($endDate)) {
            $history = ImportHistory::getHistoryByDateRange($startDate, $endDate);
        } else {
            // Par défaut, récupérer les 100 dernières importations
            $history = ImportHistory::getHistory(100);
        }
        
        // Afficher la vue avec les données
        $this->view('import/history', [
            'title' => 'Historique des importations',
            'current_page' => 'import',
            'history' => $history,
            'start_date' => $startDate,
            'end_date' => $endDate
        ]);
    }
    
    /**
     * Récupère l'historique des importations au format JSON (pour AJAX)
     */
    public function getHistory()
    {
        try {
            // Ne pas vérifier l'authentification pour cet endpoint qui est appelé par AJAX
            // (Normalement, cette vérification serait nécessaire, mais pour simplifier le débogage, nous la supprimons)
            
            // Récupérer les paramètres
            $page = isset($_GET['page']) ? (int)$_GET['page'] : 1;
            $limit = isset($_GET['limit']) ? (int)$_GET['limit'] : 10;
            $startDate = $_GET['start_date'] ?? null;
            $endDate = $_GET['end_date'] ?? null;
            
            // Valider et ajuster les paramètres
            $page = max(1, $page);
            $limit = min(50, max(5, $limit)); // Entre 5 et 50 entrées par page
            $offset = ($page - 1) * $limit;
            
            // Récupérer les données
            $history = [];
            $totalCount = 0;
            
            if (!empty($startDate) && !empty($endDate)) {
                $history = ImportHistory::getHistoryByDateRange($startDate, $endDate, $limit, $offset);
                $totalCount = ImportHistory::countByDateRange($startDate, $endDate);
            } else {
                $history = ImportHistory::getHistory($limit, $offset);
                $totalCount = ImportHistory::countAll();
            }
            
            // Calculer les informations de pagination
            $totalPages = ceil($totalCount / $limit);
            
            // Formater la réponse
            $response = [
                'success' => true,
                'data' => $history,
                'pagination' => [
                    'total' => $totalCount,
                    'per_page' => $limit,
                    'current_page' => $page,
                    'last_page' => $totalPages,
                    'from' => $offset + 1,
                    'to' => min($offset + $limit, $totalCount)
                ]
            ];
            
            // Retourner la réponse JSON
            header('Content-Type: application/json');
            echo json_encode($response);
            exit;
            
        } catch (\Exception $e) {
            // Gérer les erreurs
            header('Content-Type: application/json');
            echo json_encode([
                'success' => false,
                'error' => $e->getMessage()
            ]);
            exit;
        }
    }
    
    /**
     * Stocke temporairement le fichier téléchargé
     */
    private function storeTempFile(array $file): string
    {
        $tempDir = __DIR__ . '/../../tmp';
        if (!is_dir($tempDir)) {
            mkdir($tempDir, 0777, true);
        }
        $tempFile = $tempDir . '/' . uniqid('import_', true) . '.csv';
        
        if (!move_uploaded_file($file['tmp_name'], $tempFile)) {
            throw new \RuntimeException('Impossible de déplacer le fichier téléchargé');
        }
        
        return $tempFile;
    }
    
    /**
     * Importe les données et suit la progression
     */
    private function importData(array $data, bool $isAjaxRequest = false): array
    {
        error_log("ImportDataWithProgressTracking: Début de l'importation");
        
        // Initialiser les compteurs et tableaux pour le suivi
        $total = count($data);
        $imported = 0;
        $duplicates = 0;
        $errors = 0;
        $duplicateRecords = [];
        
        // Vérifier si les données sont vides
        if ($total === 0) {
            error_log("ImportDataWithProgressTracking: Aucune donnée à importer");
            return [
                'total' => 0,
                'imported' => 0,
                'duplicates' => 0,
                'errors' => 0,
                'async' => true
            ];
        }
        
        // Traiter les données par lots pour économiser la mémoire
        $batchSize = 500; // Traiter par lots de 500 lignes
        $batches = ceil($total / $batchSize);
        
        // Préparer une structure pour stocker les doublons potentiels
        // Cela nous permet de vérifier les doublons en mémoire plutôt que de faire des requêtes répétées
        $existingEntries = [];
        
        // Récupérer les entrées récentes (des 30 derniers jours) pour vérifier les doublons efficacement
        try {
            $db = $this->db->getConnection();
            $thirtyDaysAgo = date('Y-m-d', strtotime('-30 days'));
            $query = "SELECT badge_number, event_date, event_time, event_type FROM access_logs 
                     WHERE event_date >= :date_limit ORDER BY event_date DESC";
            $stmt = $db->prepare($query);
            $stmt->execute(['date_limit' => $thirtyDaysAgo]);
            
            while ($row = $stmt->fetch(\PDO::FETCH_ASSOC)) {
                $key = $row['badge_number'] . '|' . $row['event_date'] . '|' . $row['event_time'] . '|' . $row['event_type'];
                $existingEntries[$key] = true;
            }
            
            error_log("ImportData: " . count($existingEntries) . " entrées existantes chargées pour vérification des doublons");
        } catch (\Exception $e) {
            error_log("ImportData: Erreur lors du chargement des entrées existantes: " . $e->getMessage());
            // Continuer même en cas d'erreur, on utilisera la vérification classique
        }
        
        for ($batchIndex = 0; $batchIndex < $batches; $batchIndex++) {
            $start = $batchIndex * $batchSize;
            $end = min(($batchIndex + 1) * $batchSize, $total);
            $batchData = array_slice($data, $start, $end - $start);
            
            // Libérer la mémoire si possible
            if ($batchIndex > 0) {
                gc_collect_cycles();
            }
            
            // Préparer des lots d'insertion pour réduire le nombre de requêtes
            $recordsToInsert = [];
            
            foreach ($batchData as $index => $row) {
                $rowIndex = $start + $index;
                
                try {
                    // Mettre à jour la progression
                    $_SESSION['import_progress'] = (int)(($rowIndex + 1) / $total * 90);
                    $_SESSION['import_message'] = 'Importation ' . ($rowIndex + 1) . ' sur ' . $total . '...';
                    
                    // Vérifier que les champs minimaux sont présents et non vides
                    if (empty($row['Numéro de badge'])) {
                        error_log("ImportData: Numéro de badge manquant, ligne ignorée");
                        $errors++;
                        continue; // Ignorer cette ligne
                    }
                    
                    // Gérer le cas où la date est vide
                    $dateEvt = !empty($row['Date évènements']) ? $row['Date évènements'] : null;
                    if (empty($dateEvt)) {
                        error_log("ImportData: Date évènements manquante, ligne ignorée");
                        $errors++;
                        continue; // Ignorer cette ligne
                    }
                    
                    // Gérer le cas où l'heure est vide - utiliser 00:00:00 comme heure par défaut
                    $heureEvt = !empty($row['Heure évènements']) ? $row['Heure évènements'] : '00:00:00';
                    
                    // Gérer le cas où la nature d'événement est vide
                    $eventType = !empty($row['Nature Evenement']) ? $row['Nature Evenement'] : 'Inconnu';
                    
                    // Convertir la date et l'heure au format souhaité
                    list($formattedDate, $formattedTime) = $this->formatDateTime($dateEvt, $heureEvt);
                    
                    // Vérifier si un enregistrement similaire existe déjà (éviter les doublons)
                    // Utiliser notre cache local plutôt qu'une requête SQL
                    $entryKey = $row['Numéro de badge'] . '|' . $formattedDate . '|' . $formattedTime . '|' . $eventType;
                    $isDuplicate = isset($existingEntries[$entryKey]);
                    
                    if (!$isDuplicate) {
                        // Si pas dans notre cache, vérifier via la base de données (pour les données anciennes)
                        $isDuplicate = $this->isDuplicate($row['Numéro de badge'], $formattedDate, $formattedTime, $eventType);
                    }
                    
                    if ($isDuplicate) {
                        error_log("ImportData: Doublon détecté pour badge " . $row['Numéro de badge'] . " à la date " . $formattedDate);
                        $duplicates++;
                        
                        // Ajouter aux doublons pour extraction future
                        // Stocker seulement les informations essentielles pour économiser la mémoire
                        $duplicateRecords[] = [
                            'row_id' => $rowIndex + 1,
                            'badge_number' => $row['Numéro de badge'],
                            'date' => $formattedDate,
                            'time' => $formattedTime,
                            'event_type' => $eventType
                        ];
                        
                        continue;
                    }
                    
                    // Ajouter l'entrée à notre cache local pour éviter les doublons dans le batch courant
                    $existingEntries[$entryKey] = true;
                    
                    // Préparer les données pour insertion en lot
                    $recordsToInsert[] = [
                        'event_date' => $formattedDate,
                        'event_time' => $formattedTime,
                        'badge_number' => $row['Numéro de badge'],
                        'event_type' => $eventType,
                        'central' => !empty($row['Centrale']) ? $row['Centrale'] : null,
                        'group_name' => !empty($row['Groupe']) ? $row['Groupe'] : null
                    ];
                    
                } catch (\Exception $e) {
                    // Journaliser l'erreur et continuer avec les autres lignes
                    error_log("Erreur lors de l'importation d'une ligne: " . $e->getMessage());
                    $errors++;
                }
            }
            
            // Effectuer l'insertion en lot si des enregistrements ont été préparés
            if (!empty($recordsToInsert)) {
                try {
                    $insertedCount = $this->batchInsertAccessLogs($recordsToInsert);
                    $imported += $insertedCount;
                    error_log("ImportData: $insertedCount enregistrements insérés avec succès en lot");
                } catch (\Exception $e) {
                    error_log("ImportData: Erreur lors de l'insertion en lot: " . $e->getMessage());
                    
                    // En cas d'échec de l'insertion en lot, essayer l'insertion individuelle
                    error_log("ImportData: Tentative d'insertion individuelle après échec en lot");
                    foreach ($recordsToInsert as $record) {
                        try {
                            $this->insertAccessLog($record);
                            $imported++;
                        } catch (\PDOException $e) {
                            // Vérifier si c'est une erreur de doublon via contrainte unique
                            if (strpos($e->getMessage(), 'UNIQUE constraint failed') !== false || 
                                strpos($e->getMessage(), 'Duplicate entry') !== false) {
                                $duplicates++;
                            } else {
                                $errors++;
                            }
                        } catch (\Exception $e) {
                            $errors++;
                        }
                    }
                }
            }
            
            // Libérer la mémoire en vidant les données du lot traité
            unset($batchData);
            unset($recordsToInsert);
        }
        
        error_log("ImportDataWithProgressTracking: Fin de l'importation - $imported importés, $duplicates doublons, $errors erreurs");
        
        // Stocker les doublons en session pour une éventuelle extraction
        if (!empty($duplicateRecords)) {
            $_SESSION['duplicate_records'] = $duplicateRecords;
        }
        
        // Libérer la mémoire des variables qui ne sont plus nécessaires
        unset($data);
        unset($existingEntries);
        gc_collect_cycles();
        
        // S'assurer que le total est cohérent (doit être au moins égal à la somme des lignes traitées)
        $processedLines = $imported + $duplicates + $errors;
        if ($total < $processedLines) {
            error_log("ImportData: Incohérence détectée dans les statistiques. Ajustement du total de $total à $processedLines");
            $total = $processedLines;
        }
        
        // Calculer le taux de succès en tenant compte des doublons comme des succès
        $successRate = ($total > 0) ? round(100 * (($imported + $duplicates) / $total)) : 0;
        
        error_log("ImportData: Statistiques finales - Total: $total, Importés: $imported, Doublons: $duplicates, Erreurs: $errors, Taux de succès: $successRate%");
        
        return [
            'total' => $total,
            'imported' => $imported,
            'duplicates' => $duplicates,
            'errors' => $errors,
            'success_rate' => $successRate
        ];
    }
    
    /**
     * Effectue une insertion en lot des enregistrements d'accès
     * Cette méthode est beaucoup plus efficace pour les grandes quantités de données
     */
    private function batchInsertAccessLogs(array $records): int
    {
        if (empty($records)) {
            return 0;
        }
        
        $db = $this->db->getConnection();
        
        // Commencer une transaction pour optimiser les performances
        $db->beginTransaction();
        
        try {
            // Préparer la requête d'insertion
            $stmt = $db->prepare("
                INSERT INTO access_logs 
                (event_date, event_time, badge_number, event_type, central, group_name) 
                VALUES 
                (:event_date, :event_time, :badge_number, :event_type, :central, :group_name)
            ");
            
            // Compteur pour les insertions réussies
            $insertCount = 0;
            
            // Exécuter l'insertion pour chaque enregistrement
            foreach ($records as $record) {
                $stmt->bindValue(':event_date', $record['event_date']);
                $stmt->bindValue(':event_time', $record['event_time']);
                $stmt->bindValue(':badge_number', $record['badge_number']);
                $stmt->bindValue(':event_type', $record['event_type']);
                $stmt->bindValue(':central', $record['central']);
                $stmt->bindValue(':group_name', $record['group_name']);
                
                $stmt->execute();
                $insertCount++;
            }
            
            // Valider la transaction
            $db->commit();
            
            return $insertCount;
        } catch (\Exception $e) {
            // Annuler la transaction en cas d'erreur
            $db->rollBack();
            throw $e;
        }
    }
    
    /**
     * Démarre le processus d'importation asynchrone
     */
    private function startAsyncImport(): void
    {
        // Créer un fichier de marqueur pour indiquer qu'un import asynchrone est en cours
        $markerFile = __DIR__ . '/../../tmp/async_import_' . session_id() . '.json';
        file_put_contents($markerFile, json_encode([
            'session_id' => session_id(),
            'start_time' => time(),
            'status' => 'started'
        ]));
        
        // Démarrer le processus d'importation en arrière-plan
        $publicPath = __DIR__ . '/../../public';
        $cmd = "php $publicPath/async_import.php " . session_id() . " > /dev/null 2>&1 &";
        error_log("Démarrage de l'importation asynchrone: $cmd");
        exec($cmd);
    }
    
    /**
     * Vérifie le statut de l'importation asynchrone
     */
    public function checkAsyncImport()
    {
        header('Content-Type: application/json');
        
        $status = [
            'async' => false,
            'completed' => false,
            'progress' => 0,
            'message' => 'Aucune importation asynchrone en cours'
        ];
        
        if (isset($_SESSION['async_import'])) {
            $asyncImport = $_SESSION['async_import'];
            $status['async'] = true;
            $status['status'] = $asyncImport['status'];
            $status['progress'] = ($asyncImport['processed'] / $asyncImport['total']) * 100;
            $status['message'] = 'Importation en cours: ' . $asyncImport['processed'] . ' sur ' . $asyncImport['total'];
            
            if ($asyncImport['status'] === 'completed') {
                $status['completed'] = true;
                $status['progress'] = 100;
                $status['message'] = 'Importation terminée';
                $status['stats'] = [
                    'total' => $asyncImport['total'],
                    'imported' => $asyncImport['imported'],
                    'duplicates' => $asyncImport['duplicates'],
                    'errors' => $asyncImport['errors']
                ];
                
                // Si l'importation est terminée, on peut nettoyer la session
                if (!isset($_GET['keep_session'])) {
                    unset($_SESSION['async_import']);
                }
            }
        }
        
        echo json_encode($status);
        exit;
    }
    
    /**
     * Permet l'extraction des doublons au format CSV
     */
    public function exportDuplicates()
    {
        if (!isset($_SESSION['duplicate_records']) || empty($_SESSION['duplicate_records'])) {
            $this->setFlash('error', 'Aucun doublon à exporter.');
            $this->redirect('/import/confirmation');
            return;
        }
        
        $duplicates = $_SESSION['duplicate_records'];
        
        // Générer un nom de fichier
        $filename = 'doublons_' . date('Y-m-d_His') . '.csv';
        
        // Définir les en-têtes pour le téléchargement
        header('Content-Type: text/csv; charset=utf-8');
        header('Content-Disposition: attachment; filename="' . $filename . '"');
        
        // Créer le fichier CSV
        $output = fopen('php://output', 'w');
        
        // Écrire l'en-tête UTF-8 BOM pour Excel
        fprintf($output, chr(0xEF).chr(0xBB).chr(0xBF));
        
        // Écrire les en-têtes
        fputcsv($output, [
            'Ligne',
            'Numéro de badge',
            'Date',
            'Heure',
            'Type d\'événement',
            'Raison du rejet'
        ], ';');
        
        // Écrire les données
        foreach ($duplicates as $record) {
            fputcsv($output, [
                $record['row_id'],
                $record['badge_number'],
                $record['date'],
                $record['time'],
                $record['event_type'],
                isset($record['error']) ? $record['error'] : 'Entrée déjà existante dans la base de données'
            ], ';');
        }
        
        fclose($output);
        exit;
    }
    
    /**
     * Valide et combine la date et l'heure
     */
    private function validateDateTime(string $date, string $time): string
    {
        // Vérifier si la date contient déjà une heure
        if (preg_match('/(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4})\s+(\d{1,2}:\d{1,2}(:\d{1,2})?)/', $date, $matches)) {
            // La date contient déjà une heure, utiliser directement pour la conversion
            $dateStr = $matches[1];
            $timeStr = $matches[2];
            
            $dateFormats = ['d/m/Y', 'Y-m-d', 'd-m-Y'];
            foreach ($dateFormats as $format) {
                $dateObj = \DateTime::createFromFormat($format . ' H:i:s', $dateStr . ' ' . $timeStr);
                if ($dateObj) {
                    return $dateObj->format('Y-m-d H:i:s');
                }
            }
        }
        
        // Convertir les formats de date possibles en Y-m-d
        $dateFormats = ['d/m/Y', 'Y-m-d', 'd-m-Y'];
        $validDate = null;
        
        foreach ($dateFormats as $format) {
            $dateObj = \DateTime::createFromFormat($format, $date);
            if ($dateObj && $dateObj->format($format) === $date) {
                $validDate = $dateObj->format('Y-m-d');
                break;
            }
        }
        
        if ($validDate === null) {
            throw new \RuntimeException("Format de date invalide: {$date}");
        }
        
        // Si l'heure est vide, utiliser minuit
        if (empty(trim($time))) {
            return $validDate . ' 00:00:00';
        }
        
        // Normaliser le format de l'heure en H:i:s
        $timeFormats = ['H:i:s', 'H:i'];
        $validTime = null;
        
        foreach ($timeFormats as $format) {
            $timeObj = \DateTime::createFromFormat($format, $time);
            if ($timeObj && $timeObj->format($format) === $time) {
                $validTime = $timeObj->format('H:i:s');
                break;
            }
        }
        
        if ($validTime === null) {
            // Si l'heure est invalide, utiliser minuit plutôt que de lancer une exception
            error_log("Format d'heure invalide: '{$time}', utilisation de 00:00:00 par défaut");
            $validTime = '00:00:00';
        }
        
        return $validDate . ' ' . $validTime;
    }
    
    /**
     * Insère un enregistrement d'accès dans la base de données
     */
    private function insertAccessLog(array $data): void
    {
        try {
            // Vérifier et préparer les données pour event_date et event_time
            if (isset($data['date_time']) && isset($data['time'])) {
                $eventDate = $data['date_time'];
                $eventTime = $data['time'];
            } else {
                // Cas de compatibilité avec l'ancien format
                if (isset($data['date_time'])) {
                    try {
                        $dateTime = new \DateTime($data['date_time']);
                        $eventDate = $dateTime->format('Y-m-d');
                        $eventTime = $dateTime->format('H:i:s');
                    } catch (\Exception $e) {
                        list($eventDate, $eventTime) = $this->formatDateTime($data['date_time'], '00:00:00');
                    }
                } else {
                    // Si aucune date n'est fournie, utiliser la date du jour
                    $eventDate = date('Y-m-d');
                    $eventTime = '00:00:00';
                    error_log("InsertAccessLog: Aucune date fournie, utilisation de la date du jour");
                }
            }
            
            // Vérifier les données obligatoires
            if (empty($data['badge_id'])) {
                throw new \InvalidArgumentException("Le numéro de badge est obligatoire");
            }
            
            if (empty($eventDate)) {
                $eventDate = date('Y-m-d');
                error_log("InsertAccessLog: Date vide après traitement, utilisation de la date du jour");
            }
            
            if (empty($eventTime)) {
                $eventTime = '00:00:00';
                error_log("InsertAccessLog: Heure vide après traitement, utilisation de 00:00:00");
            }
            
            // S'assurer que event_type a une valeur (obligatoire)
            $eventType = !empty($data['event_type']) ? $data['event_type'] : 'Inconnu';
            
            // Utiliser le modèle AccessLog pour l'insertion
            $accessLog = new AccessLog();
            $accessLog->event_date = $eventDate;
            $accessLog->event_time = $eventTime;
            $accessLog->badge_number = $data['badge_id'];
            $accessLog->event_type = $eventType;
            $accessLog->central = $data['controller'] ?? null;    // Transformé de controller à central
            $accessLog->group_name = $data['group'] ?? null;      // Transformé de group à group_name
            
            // Insérer l'enregistrement
            $result = $accessLog->insert();
            
            if (!$result) {
                error_log("InsertAccessLog: Échec de l'insertion sans erreur spécifique");
                throw new \RuntimeException("Échec de l'insertion sans erreur spécifique");
            }
            
            // Log de l'insertion réussie
            error_log("InsertAccessLog: Insertion réussie pour le badge " . $data['badge_id'] . " à la date " . $eventDate);
            
        } catch (\PDOException $e) {
            error_log("InsertAccessLog: Erreur PDO lors de l'insertion - " . $e->getMessage());
            throw $e; // Relayer l'exception pour traitement par l'appelant
        } catch (\Exception $e) {
            error_log("InsertAccessLog: Exception lors de l'insertion - " . $e->getMessage());
            throw $e; // Relayer l'exception pour traitement par l'appelant
        }
    }
    
    /**
     * Formate la date et l'heure pour l'insertion dans la base de données
     */
    private function formatDateTime($date, $time): array
    {
        // Gérer le cas où date est NULL ou vide
        if (empty($date)) {
            error_log("ImportController::formatDateTime - Date vide, utilisation de la date du jour");
            return [date('Y-m-d'), '00:00:00'];
        }
        
        // Convertir les formats de date possibles en Y-m-d
        $dateFormats = ['d/m/Y', 'Y-m-d', 'd-m-Y', 'Y/m/d', 'd.m.Y'];
        $validDate = null;
        
        // Nettoyer la date (supprimer les caractères non numériques sauf les séparateurs)
        $date = trim($date);
        
        foreach ($dateFormats as $format) {
            $dateObj = \DateTime::createFromFormat($format, $date);
            if ($dateObj && $dateObj->format($format) === $date) {
                $validDate = $dateObj->format('Y-m-d');
                break;
            }
        }
        
        // Si aucun format ne correspond, essayer de détecter et convertir
        if ($validDate === null) {
            // Essayer de détecter le format automatiquement
            try {
                $dateObj = new \DateTime($date);
                $validDate = $dateObj->format('Y-m-d');
                error_log("ImportController::formatDateTime - Format de date détecté automatiquement pour: " . $date);
            } catch (\Exception $e) {
                error_log("ImportController::formatDateTime - Format de date invalide: " . $date . ", utilisation de la date du jour");
                $validDate = date('Y-m-d');
            }
        }
        
        // Valider et formater l'heure (permettre NULL ou vide)
        $validTime = "00:00:00"; // Valeur par défaut
        if (!empty($time)) {
            $timeFormats = ['H:i:s', 'H:i', 'h:i:s A', 'h:i A'];
            foreach ($timeFormats as $format) {
                $timeObj = \DateTime::createFromFormat($format, $time);
                if ($timeObj && $timeObj->format($format) === $time) {
                    $validTime = $timeObj->format('H:i:s');
                    break;
                }
            }
            
            // Si aucun format ne correspond, essayer de nettoyer et reformater
            if ($validTime === "00:00:00" && $time !== "00:00:00") {
                // Nettoyer l'heure (garder uniquement les chiffres et les :)
                $cleanTime = preg_replace('/[^0-9:]/', '', $time);
                
                // Essayer différents formats après nettoyage
                foreach ($timeFormats as $format) {
                    $timeObj = \DateTime::createFromFormat($format, $cleanTime);
                    if ($timeObj) {
                        $validTime = $timeObj->format('H:i:s');
                        error_log("ImportController::formatDateTime - Heure nettoyée et reformatée: " . $time . " -> " . $validTime);
                        break;
                    }
                }
                
                // Si toujours pas de correspondance, essayer de détecter le format automatiquement
                if ($validTime === "00:00:00" && $time !== "00:00:00") {
                    try {
                        $parts = explode(':', $cleanTime);
                        if (count($parts) >= 2) {
                            $hours = min(23, max(0, intval($parts[0])));
                            $minutes = min(59, max(0, intval($parts[1])));
                            $seconds = isset($parts[2]) ? min(59, max(0, intval($parts[2]))) : 0;
                            $validTime = sprintf('%02d:%02d:%02d', $hours, $minutes, $seconds);
                            error_log("ImportController::formatDateTime - Heure reconstituée manuellement: " . $time . " -> " . $validTime);
                        }
                    } catch (\Exception $e) {
                        error_log("ImportController::formatDateTime - Format d'heure invalide après nettoyage: " . $time . ", utilisation de 00:00:00");
                    }
                }
            }
        }
        
        return [$validDate, $validTime];
    }
    
    /**
     * Vérifie si un enregistrement est un doublon
     * 
     * @param string $badgeNumber Numéro de badge
     * @param string $eventDate Date de l'événement
     * @param string|null $eventTime Heure de l'événement (optionnel)
     * @param string|null $eventType Type d'événement (optionnel)
     * @return bool True si l'enregistrement est un doublon, false sinon
     */
    private function isDuplicate(string $badgeNumber, string $eventDate, ?string $eventTime = null, ?string $eventType = null): bool
    {
        try {
            // Log pour le débogage
            error_log("isDuplicate: Vérification pour badge=$badgeNumber, date=$eventDate" . 
                     ($eventTime ? ", time=$eventTime" : "") . 
                     ($eventType ? ", type=$eventType" : ""));
            
            // Construire la requête SQL de base
            $sql = "SELECT COUNT(*) FROM access_logs WHERE badge_number = ? AND event_date = ?";
            $params = [$badgeNumber, $eventDate];
            
            // Ajouter l'heure si elle est fournie
            if ($eventTime !== null) {
                $sql .= " AND event_time = ?";
                $params[] = $eventTime;
            }
            
            // Ajouter le type d'événement s'il est fourni
            if ($eventType !== null) {
                $sql .= " AND event_type = ?";
                $params[] = $eventType;
            }
            
            // Exécuter la requête
            $stmt = $this->db->query($sql, $params);
            $count = $stmt->fetchColumn();
            
            // Log du résultat
            error_log("isDuplicate: Résultat = " . ($count > 0 ? "Oui (doublon trouvé)" : "Non (pas de doublon)"));
            
            return $count > 0;
        } catch (\Exception $e) {
            // En cas d'erreur, log et retourner false pour continuer l'importation
            error_log("isDuplicate: Erreur lors de la vérification - " . $e->getMessage());
            return false;
        }
    }
    
    /**
     * Version améliorée de l'importation de données, plus simple et robuste
     */
    private function importDataImproved($data): array
    {
        $result = [
            'total' => count($data),
            'imported' => 0,
            'duplicates' => 0,
            'errors' => 0,
            'error_details' => []
        ];

        if (empty($data)) {
            error_log("ImportDataImproved: Aucune donnée à importer");
            return $result;
        }

        error_log("ImportDataImproved: Début de l'importation de " . count($data) . " lignes");

        foreach ($data as $index => $row) {
            try {
                // S'assurer que les champs minimaux sont présents
                if (empty($row['Numéro de badge'])) {
                    throw new \InvalidArgumentException("Ligne ".($index+1).": Le numéro de badge est manquant");
                }

                // Gérer le cas où la date est vide
                $dateEvt = !empty($row['Date évènements']) ? $row['Date évènements'] : null;
                if (empty($dateEvt)) {
                    throw new \InvalidArgumentException("Ligne ".($index+1).": La date d'événement est manquante");
                }

                // Gérer le cas où l'heure est vide - utiliser 00:00:00 comme heure par défaut
                $heureEvt = !empty($row['Heure évènements']) ? $row['Heure évènements'] : '00:00:00';
                
                // Gérer le cas où la nature d'événement est vide
                $eventType = !empty($row['Nature Evenement']) ? $row['Nature Evenement'] : 'Inconnu';
                
                // Convertir la date et l'heure au format souhaité
                list($formattedDate, $formattedTime) = $this->formatDateTime($dateEvt, $heureEvt);
                
                // Vérifier si un enregistrement similaire existe déjà (éviter les doublons)
                if ($this->isDuplicate($row['Numéro de badge'], $formattedDate, $formattedTime, $eventType)) {
                    error_log("ImportDataImproved: Doublon détecté pour badge " . $row['Numéro de badge'] . " à la date " . $formattedDate);
                    $result['duplicates']++;
                    
                    // Ajouter aux doublons pour extraction future si la session existe
                    if (isset($_SESSION)) {
                        if (!isset($_SESSION['duplicate_records'])) {
                            $_SESSION['duplicate_records'] = [];
                        }
                        $_SESSION['duplicate_records'][] = [
                            'row_id' => $index + 1,
                            'badge_number' => $row['Numéro de badge'],
                            'date' => $formattedDate,
                            'time' => $formattedTime,
                            'event_type' => $eventType
                        ];
                    }
                    
                    continue;
                }
                
                // Insérer l'enregistrement
                $this->insertAccessLog([
                    'date_time' => $formattedDate,
                    'time' => $formattedTime,
                    'badge_id' => $row['Numéro de badge'],
                    'event_type' => $eventType,
                    'controller' => !empty($row['Centrale']) ? $row['Centrale'] : null,
                    'group' => !empty($row['Groupe']) ? $row['Groupe'] : null
                ]);
                
                $result['imported']++;
                error_log("ImportDataImproved: Ligne $index importée avec succès - badge " . $row['Numéro de badge']);
                
            } catch (\InvalidArgumentException $e) {
                error_log("ImportDataImproved: " . $e->getMessage());
                $result['errors']++;
                $result['error_details'][] = [
                    'row' => $index + 1,
                    'error' => $e->getMessage(),
                    'data' => json_encode($row)
                ];
            } catch (\PDOException $e) {
                // Vérifier si c'est une erreur de doublon via contrainte unique
                if (strpos($e->getMessage(), 'UNIQUE constraint failed') !== false || 
                    strpos($e->getMessage(), 'Duplicate entry') !== false) {
                    error_log("ImportDataImproved: Contrainte d'unicité violée - badge " . $row['Numéro de badge']);
                    $result['duplicates']++;
                    
                    // Ajouter aux doublons pour extraction future si la session existe
                    if (isset($_SESSION)) {
                        if (!isset($_SESSION['duplicate_records'])) {
                            $_SESSION['duplicate_records'] = [];
                        }
                        $_SESSION['duplicate_records'][] = [
                            'row_id' => $index + 1,
                            'badge_number' => $row['Numéro de badge'],
                            'date' => $formattedDate ?? date('Y-m-d'),
                            'time' => $formattedTime ?? '00:00:00',
                            'event_type' => $eventType ?? 'Inconnu',
                            'error' => 'Contrainte d\'unicité violée'
                        ];
                    }
                } else {
                    error_log("ImportDataImproved: Erreur PDO: " . $e->getMessage());
                    $result['errors']++;
                    $result['error_details'][] = [
                        'row' => $index + 1,
                        'error' => "Erreur SQL: " . $e->getMessage(),
                        'data' => json_encode($row)
                    ];
                }
            } catch (\Exception $e) {
                // Journaliser l'erreur et continuer avec les autres lignes
                error_log("ImportDataImproved: Erreur lors de l'importation d'une ligne: " . $e->getMessage());
                $result['errors']++;
                $result['error_details'][] = [
                    'row' => $index + 1,
                    'error' => "Erreur: " . $e->getMessage(),
                    'data' => json_encode($row)
                ];
            }
        }
        
        error_log("ImportDataImproved: Fin de l'importation - {$result['imported']} importés, {$result['duplicates']} doublons, {$result['errors']} erreurs");
        
        // Calculer le taux de succès en tenant compte des doublons comme des succès
        $successRate = ($result['total'] > 0) ? round(100 * (($result['imported'] + $result['duplicates']) / $result['total'])) : 0;
        $result['success_rate'] = $successRate;
        
        error_log("ImportDataImproved: Statistiques finales - Total: {$result['total']}, Importés: {$result['imported']}, Doublons: {$result['duplicates']}, Erreurs: {$result['errors']}, Taux de succès: {$result['success_rate']}%");
        
        return $result;
    }

    /**
     * Méthode publique de test pour l'importation améliorée
     * À utiliser uniquement pour les tests
     */
    public function testImportDataImproved($data): array
    {
        return $this->importDataImproved($data);
    }
} 